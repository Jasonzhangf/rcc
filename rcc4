#!/usr/bin/env node

/**
 * RCC4 Command Line Interface
 * 
 * Usage:
 *   rcc4 start [--port PORT]    - Start RCC4 system and wait for Ctrl+C
 *   rcc4 stop                   - Stop RCC4 system
 *   rcc4 code [--port PORT]     - Start RCC4 and launch Claude with environment override
 * 
 * Default port: 5506
 */

const fs = require('fs');
const path = require('path');
const { spawn, exec } = require('child_process');
const os = require('os');

class RCC4CLI {
  constructor() {
    this.defaultPort = 5506;
    this.pidDir = path.join(os.tmpdir(), 'rcc4');
    this.configPath = './config.json';
    this.startupScript = path.join(__dirname, 'rcc4-system-startup.js');
    
    // Ensure PID directory exists
    if (!fs.existsSync(this.pidDir)) {
      fs.mkdirSync(this.pidDir, { recursive: true });
    }
  }

  /**
   * Parse command line arguments
   */
  parseArgs() {
    const args = process.argv.slice(2);
    const command = args[0];
    const options = {};
    
    // Parse --port argument
    const portIndex = args.indexOf('--port');
    if (portIndex !== -1 && args[portIndex + 1]) {
      options.port = parseInt(args[portIndex + 1], 10);
      if (isNaN(options.port) || options.port < 1 || options.port > 65535) {
        this.error(`Invalid port number: ${args[portIndex + 1]}`);
        process.exit(1);
      }
    } else {
      options.port = this.defaultPort;
    }
    
    return { command, options };
  }

  /**
   * Get PID file path for a specific port
   */
  getPidFile(port) {
    return path.join(this.pidDir, `rcc4-${port}.pid`);
  }

  /**
   * Check if RCC4 is running on specified port
   */
  async isRunning(port) {
    const pidFile = this.getPidFile(port);
    
    if (!fs.existsSync(pidFile)) {
      return false;
    }
    
    try {
      const pid = fs.readFileSync(pidFile, 'utf8').trim();
      // Check if process is still running
      process.kill(pid, 0);
      return parseInt(pid);
    } catch (error) {
      // Process not running, clean up stale PID file
      fs.unlinkSync(pidFile);
      return false;
    }
  }

  /**
   * Save PID to file
   */
  savePid(port, pid) {
    const pidFile = this.getPidFile(port);
    fs.writeFileSync(pidFile, pid.toString());
  }

  /**
   * Remove PID file
   */
  removePid(port) {
    const pidFile = this.getPidFile(port);
    if (fs.existsSync(pidFile)) {
      fs.unlinkSync(pidFile);
    }
  }

  /**
   * Kill process by port (fallback method)
   */
  async killByPort(port) {
    return new Promise((resolve) => {
      exec(`lsof -ti:${port}`, (error, stdout) => {
        if (error || !stdout.trim()) {
          resolve(false);
          return;
        }
        
        const pids = stdout.trim().split('\n');
        let killed = false;
        
        pids.forEach(pid => {
          try {
            process.kill(parseInt(pid), 'SIGTERM');
            killed = true;
          } catch (e) {}
        });
        
        resolve(killed);
      });
    });
  }

  /**
   * Start RCC4 system
   */
  async start(options) {
    const { port } = options;
    
    // Check if already running
    const existingPid = await this.isRunning(port);
    if (existingPid) {
      this.info(`RCC4 is already running on port ${port} (PID: ${existingPid})`);
      return;
    }
    
    this.info(`ðŸš€ Starting RCC4 system on port ${port}...`);
    
    // Set environment variables
    const env = {
      ...process.env,
      RCC4_CONFIG: this.configPath,
      RCC4_PORT: port.toString()
    };
    
    // Spawn RCC4 process
    const child = spawn('node', [this.startupScript], {
      env,
      stdio: ['ignore', 'inherit', 'inherit']
    });
    
    // Save PID
    this.savePid(port, child.pid);
    
    // Setup graceful shutdown
    const cleanup = async () => {
      this.info('\nðŸ“¦ Shutting down RCC4 system...');
      try {
        process.kill(child.pid, 'SIGTERM');
        this.removePid(port);
        this.info('âœ… RCC4 system stopped gracefully');
      } catch (error) {
        this.error(`Error stopping RCC4: ${error.message}`);
      }
      process.exit(0);
    };
    
    process.on('SIGINT', cleanup);
    process.on('SIGTERM', cleanup);
    
    // Handle child process exit
    child.on('exit', (code) => {
      this.removePid(port);
      if (code !== 0) {
        this.error(`RCC4 system exited with code ${code}`);
        process.exit(code);
      }
    });
    
    child.on('error', (error) => {
      this.error(`Failed to start RCC4: ${error.message}`);
      this.removePid(port);
      process.exit(1);
    });
    
    // Keep the process running
    this.info(`âœ… RCC4 system started on port ${port} (PID: ${child.pid})`);
    this.info('ðŸ“ Press Ctrl+C to stop the system gracefully');
    
    // Wait for process to exit
    await new Promise((resolve) => {
      child.on('exit', resolve);
    });
  }

  /**
   * Stop RCC4 system
   */
  async stop(options) {
    const { port } = options;
    
    const existingPid = await this.isRunning(port);
    if (!existingPid) {
      this.info(`RCC4 is not running on port ${port}`);
      return;
    }
    
    this.info(`ðŸ›‘ Stopping RCC4 system on port ${port} (PID: ${existingPid})...`);
    
    try {
      // Send SIGTERM for graceful shutdown
      process.kill(existingPid, 'SIGTERM');
      
      // Wait a bit for graceful shutdown
      await new Promise(resolve => setTimeout(resolve, 2000));
      
      // Check if still running
      const stillRunning = await this.isRunning(port);
      if (stillRunning) {
        // Force kill if still running
        process.kill(existingPid, 'SIGKILL');
        await new Promise(resolve => setTimeout(resolve, 1000));
      }
      
      this.removePid(port);
      this.info('âœ… RCC4 system stopped');
      
    } catch (error) {
      // Try killing by port as fallback
      const killed = await this.killByPort(port);
      this.removePid(port);
      
      if (killed) {
        this.info('âœ… RCC4 system stopped (force killed)');
      } else {
        this.error(`Failed to stop RCC4: ${error.message}`);
        process.exit(1);
      }
    }
  }

  /**
   * Start RCC4 and launch Claude with environment override
   */
  async code(options) {
    const { port } = options;
    
    // Check if already running
    const existingPid = await this.isRunning(port);
    if (existingPid) {
      this.info(`RCC4 is already running on port ${port} (PID: ${existingPid})`);
    } else {
      this.info(`ðŸš€ Starting RCC4 system on port ${port}...`);
      
      // Start RCC4 in background
      const env = {
        ...process.env,
        RCC4_CONFIG: this.configPath,
        RCC4_PORT: port.toString()
      };
      
      const child = spawn('node', [this.startupScript], {
        env,
        stdio: ['ignore', 'pipe', 'pipe'],
        detached: true
      });
      
      child.unref();
      this.savePid(port, child.pid);
      
      // Wait a moment for startup
      await new Promise(resolve => setTimeout(resolve, 2000));
      
      this.info(`âœ… RCC4 system started on port ${port} (PID: ${child.pid})`);
    }
    
    // Set environment variables for Claude
    const claudeEnv = {
      ...process.env,
      ANTHROPIC_API_URL: `http://localhost:${port}/v1`,
      OPENAI_API_URL: `http://localhost:${port}/v1`,
      OPENAI_BASE_URL: `http://localhost:${port}/v1`
    };
    
    this.info(`ðŸ¤– Launching Claude with RCC4 proxy (port ${port})...`);
    this.info('ðŸ”— Environment variables set:');
    this.info(`   ANTHROPIC_API_URL=http://localhost:${port}/v1`);
    this.info(`   OPENAI_API_URL=http://localhost:${port}/v1`);
    this.info(`   OPENAI_BASE_URL=http://localhost:${port}/v1`);
    
    // Launch Claude
    const claude = spawn('claude', [], {
      env: claudeEnv,
      stdio: 'inherit'
    });
    
    claude.on('error', (error) => {
      if (error.code === 'ENOENT') {
        this.error('Claude command not found. Please make sure Claude CLI is installed.');
        this.info('You can install it with: npm install -g @anthropic-ai/claude-cli');
      } else {
        this.error(`Failed to launch Claude: ${error.message}`);
      }
      process.exit(1);
    });
    
    claude.on('exit', (code) => {
      this.info('ðŸ‘‹ Claude session ended');
      process.exit(code);
    });
  }

  /**
   * Show usage information
   */
  showUsage() {
    console.log(`
RCC4 Command Line Interface

Usage:
  rcc4 start [--port PORT]    Start RCC4 system and wait for Ctrl+C
  rcc4 stop [--port PORT]     Stop RCC4 system  
  rcc4 code [--port PORT]     Start RCC4 and launch Claude with environment override

Options:
  --port PORT                 Specify port number (default: ${this.defaultPort})

Examples:
  rcc4 start                  Start RCC4 on default port ${this.defaultPort}
  rcc4 start --port 8080      Start RCC4 on port 8080
  rcc4 stop                   Stop RCC4 on default port
  rcc4 code --port 7777       Start RCC4 on port 7777 and launch Claude
`);
  }

  /**
   * Logging helpers
   */
  info(message) {
    console.log(`[RCC4] ${message}`);
  }

  error(message) {
    console.error(`[RCC4 ERROR] ${message}`);
  }

  /**
   * Main entry point
   */
  async run() {
    const { command, options } = this.parseArgs();
    
    switch (command) {
      case 'start':
        await this.start(options);
        break;
        
      case 'stop':
        await this.stop(options);
        break;
        
      case 'code':
        await this.code(options);
        break;
        
      case 'help':
      case '--help':
      case '-h':
        this.showUsage();
        break;
        
      default:
        if (!command) {
          this.showUsage();
        } else {
          this.error(`Unknown command: ${command}`);
          this.showUsage();
          process.exit(1);
        }
    }
  }
}

// Run CLI if called directly
if (require.main === module) {
  const cli = new RCC4CLI();
  cli.run().catch(error => {
    console.error(`[RCC4 FATAL] ${error.message}`);
    process.exit(1);
  });
}

module.exports = RCC4CLI;